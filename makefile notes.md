# Makefile Notes

## Rules

The syntax of a typical rule:

```make
target: prerequisites
    recipe
```

Target works like a function name, with prerequisites or dependencies following the target. Recipe uses prerequisites to make a target. A target, prerequisites, and recipes together make a rule. As an example:

```make
#print onto terminal
hello: #prerequisites are optional
	echo "hello world"
```

You can create a program with a makefile, in this example with the command 
`make test`
:

```make
#searches for 'test' first, requires test.o, searches for that
test: test.o #runs 3rd
	gcc test.o -o test 

#requires test.c, searches for test.c,
test.o : test.c #runs 2nd
	gcc -c test.c -o test.o 

test.c: #has no dependencies, so this is run 1st
	echo "int main() { return 0; }" > test.c

#cleans up files generated by make
clean:
	rm -f test.c test.o test
```
| Flag or Command     | Description |
| ----------- | ----------- |
| -o      | in this context, indicates an output, to the current directory unless otherwise defined |
| gcc  | stands for gnu compiler collections, used to compile c and c++ code |
| echo | displays a string | 
| rm | remove (or delete) a file |
| -f | in this context, indicates force, so that the compiler will remove the files wihout prompting confirmation |

## Variables
Variables can only be strings. A basic example:

```make
files := file1 file2

#makes file1 and file2 because they are required
#variable allows multiple prerequisites to be passed with one id
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

#these targets create files
#touch updates the file modification time so they are not considered old
file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

Variables can be appended:

```make
one = hello
# one gets defined as a simply expanded variable (:=) and thus can handle appending
one := ${one} there

all: 
	echo $(one)
```

or with:

```make
foo := start
foo += more

all: 
	echo $(foo)
```

?= can be used to define a variable only if they have not been defined already.

### Wildcards

The 
`*`
wildcard searches your filesystem for matching filenames. It is helpful to wrap it in the 
`wildcard` 
function, otherwise it may be simply interpreted as a string.

```make
# print out file information about every .c file
print: $(wildcard *.c)
	ls -la  $?
```
| | | 
| -- | -- | 
| ls | lists files in directory |
| -la | provides additional options to ls command, providing info on read/write access, owner account, group name, file size, time of last modification, and file name. |

The 
`%`
wildcard can be used in two modes:
* Matching - matches one or more characters in a string. the match is called a stem.
* Replacing - takes a matched stem and replaces that in a string.

It is most useful for:
* Pattern Rules and Static Pattern Rules
* String Substitution
* The vpath Directive

### Automatic Variables

There are [many](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html) automatic variables. Very commonly you'll see:

| Automatic Variable | Description |
| -- | -- |
| `$@` | the filename of the target of the rule. if the target is an archive member, then `$@` is  the name of the archive file. in a pattern rule with multiple targets, `$@` is the name of whichver target caused the rule's recipe to be run |
| `$?` | the names of all the prerequisites that are newer than the target, with spaces in between. if the target does not exist, all prerequisites wil be included. for prerequisites that are archvie members, only the named member is used. |
|`$^` | the names of all the prerequisites, with spaces between them. for prerequisites which are archive members, only the named member is used. if a prerequisite is listed more than once for a target, the value of `$^` contains just one copy of the name. this list does *not* contain any of the order-only prerequisites (for which ` $\| ` is required) |

```make
one: two three
	echo $@
	echo $?
	echo $^
	touch one

two:
	touch two

three:
	touch three

clean:
	rm -f one two three
```

### File Name Functions for Variables

For most functional applications of strings (for file names) see the GNU documentation [here](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions).


## Targets

If you have multiple targets and want all of them to run, use the all target:

```make
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```

When there are multiple targets for a rule, the commands will be run for each target. 
`$@`
is an automatic variable that contains the target name. Example:

```make
all: one.o two.o

one.o two.o:
	echo $@
# Equivalent to:
# one.o:
#	 echo one.o
# two.o:
#	 echo two.o
```

## Implicit Rules

| Implicit Rules | Definition | From Command |
| -- | -- | -- | 
| Compiling C | a.o is made automatically from a.c | `$(CC) -c $(CPPFLAGS) $(CFLAGS)` |
| Compiling C++ | a.o is made automatically from a.cc or a.cpp | `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)` |
| Linking a single object file | a is made automatically from a.o | `$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)`|

Important Variables:
| | |
| -- | -- |
| `CC` | program for compiling C programs; default `cc` | 
| `CXX` | program for compiling C++ programs; default `g++` |
| `CFLAGS` | extra flags to give to the C compiler |
| `CXXFLAGS` | extra flags to give to the C++ compiler |
| `CPPFLAGS` | extra flags to tive to the C preprocessor |
| `LDFLAGS` | extra flags to give to compilers when they are supposed to invoke the linker | 

```make
CC = gcc # Flag for implicit rules
CFLAGS = -g # Flag for implicit rules. Turn on debug info

# Implicit rule #1: test.c is built via the C linker implicit rule
# Implicit rule #2: test.o is built via the C compilation implicit rule, because test.c exists
# Implicit rule #3: test is built via the C linker implicit rule
test: test.o

test.c:
	echo "int main() { return 0; }" > test.c

clean:
	rm -f test*
```

## General Concepts

* Flags can be arranged in any order, ie:
 `ls -la`
is equivalent to 
`ls -al`

* If you want to understand why a specific flag is being used with a command, consult the
manual: 
`man ls`

# Sources
* https://makefiletutorial.com/
* https://www.gnu.org/software/make/manual/make.html
# Notes
Alternatives to traditional makefiles:
* https://cmake.org/
* https://bazel.build/
* https://ninja-build.org/
* https://scons.org/