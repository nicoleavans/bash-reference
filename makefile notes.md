# Makefile Notes

## Rules

The syntax of a typical rule:

```make
target: prerequisites
    recipe
```

Target works like a function name, with prerequisites or dependencies following the target. Recipe uses prerequisites to make a target. A target, prerequisites, and recipes together make a rule. As an example:

```make
#print onto terminal
hello: #prerequisites are optional
	echo "hello world"
```

You can create a program with a makefile, in this example with the command 
`make test`
:

```make
#searches for 'test' first, requires test.o, searches for that
test: test.o #runs 3rd
	gcc test.o -o test 

#requires test.c, searches for test.c,
test.o : test.c #runs 2nd
	gcc -c test.c -o test.o 

test.c: #has no dependencies, so this is run 1st
	echo "int main() { return 0; }" > test.c

#cleans up files generated by make
clean:
	rm -f test.c test.o test
```
| Flag or Command     | Description |
| ----------- | ----------- |
| -o      | in this context, indicates an output, to the current directory unless otherwise defined |
| gcc  | stands for gnu compiler collections, used to compile c and c++ code |
| echo | displays a string | 
| rm | remove (or delete) a file |
| -f | in this context, indicates force, so that the compiler will remove the files wihout prompting confirmation |

## Variables
Variables can only be strings. A basic example:

```make
files := file1 file2

#makes file1 and file2 because they are required
#variable allows multiple prerequisites to be passed with one id
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

#these targets create files
#touch updates the file modification time so they are not considered old
file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

Variables can be appended:

```make
one = hello
# one gets defined as a simply expanded variable (:=) and thus can handle appending
one := ${one} there

all: 
	echo $(one)
```

or with:

```make
foo := start
foo += more

all: 
	echo $(foo)
```

?= can be used to define a variable only if they have not been defined already.

### Automatic Variables and Wildcards

The 
`*`
wildcard searches your filesystem for matching filenames. It is helpful to wrap it in the 
`wildcard` 
function, otherwise it may be simply interpreted as a string.

```make
# print out file information about every .c file
print: $(wildcard *.c)
	ls -la  $?
```
| | | 
| -- | -- | 
| ls | lists files in directory |
| -l | provides additional options to ls command, providing info on read/write access, owner account, group name, file size, time of last modification, and file name. works the same as -la or -al |

### File Name Functions for Variables

For most functional applications of strings (for file names) see the GNU documentation [here](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions).

## Targets

If you have multiple targets and want all of them to run, use the all target:

```make
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```

When there are multiple targets for a rule, the commands will be run for each target. 
`$@`
is an automatic variable that contains the target name. Example:

```make
all: one.o two.o

one.o two.o:
	echo $@
# Equivalent to:
# one.o:
#	 echo one.o
# two.o:
#	 echo two.o
```

# Sources
* https://makefiletutorial.com/
* https://www.gnu.org/software/make/manual/make.html
# Notes
Alternatives to traditional makefiles:
* https://cmake.org/
* https://bazel.build/
* https://ninja-build.org/
* https://scons.org/