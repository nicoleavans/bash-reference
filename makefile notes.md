# Makefile Notes

## Rules

The syntax of a typical rule:

```make
target: prerequisites
    recipe
```

Target works like a function name, with prerequisites or dependencies following the target. Recipe uses prerequisites to make a target. A target, prerequisites, and recipes together make a rule. As an example:

```make
#print onto terminal
hello: #prerequisites are optional
	echo "hello world"
```

You can create a program with a makefile, in this example with the command 
`make test`
:

```make
#searches for 'test' first, requires test.o, searches for that
test: test.o #runs 3rd
	gcc test.o -o test 

#requires test.c, searches for test.c,
test.o : test.c #runs 2nd
	gcc -c test.c -o test.o 

test.c: #has no dependencies, so this is run 1st
	echo "int main() { return 0; }" > test.c

#cleans up files generated by make
clean:
	rm -f test.c test.o test
```
| Flag or Command     | Description |
| ----------- | ----------- |
| -o      | in this context, indicates an output, to the current directory unless otherwise defined |
| gcc  | stands for gnu compiler collections, used to compile c and c++ code |
| echo | displays a string | 
| rm | remove (or delete) a file |
| -f | in this context, indicates force, so that the compiler will remove the files wihout prompting confirmation |

## Variables
Variables can only be strings. A basic example:

```make
files := file1 file2

#makes file1 and file2 because they are required
#variable allows multiple prerequisites to be passed with one id
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

#these targets create files
#touch updates the file modification time so they are not considered old
file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

Variables can be appended using
`:=`
or
`+=`
:

```make
one = hello
# one gets defined as a simply expanded variable (:=) and thus can handle appending
one := ${one} there

all: 
	echo $(one)
```

or with:

```make
foo := start
foo += more

all: 
	echo $(foo)
```

`?=`
 can be used to define a variable only if they have not been defined already.

### Wildcards

The 
`*`
wildcard searches your filesystem for matching filenames. It is helpful to wrap it in the 
`wildcard` 
function, otherwise it may be simply interpreted as a string.

```make
# print out file information about every .c file
print: $(wildcard *.c)
	ls -la  $?
```
| | | 
| -- | -- | 
| ls | lists files in directory |
| -la | provides additional options to ls command, providing info on read/write access, owner account, group name, file size, time of last modification, and file name. |

The 
`%`
wildcard can be used in two modes:
* Matching - matches one or more characters in a string. the match is called a stem.
* Replacing - takes a matched stem and replaces that in a string.

It is most useful for:
* Pattern Rules and Static Pattern Rules
* String Substitution
* The vpath Directive

### Automatic Variables

There are [many](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html) automatic variables. Very commonly you'll see:

| Automatic Variable | Description |
| -- | -- |
| `$@` | the filename of the target of the rule. if the target is an archive member, then `$@` is  the name of the archive file. in a pattern rule with multiple targets, `$@` is the name of whichver target caused the rule's recipe to be run |
| `$?` | the names of all the prerequisites that are newer than the target, with spaces in between. if the target does not exist, all prerequisites wil be included. for prerequisites that are archvie members, only the named member is used. |
|`$^` | the names of all the prerequisites, with spaces between them. for prerequisites which are archive members, only the named member is used. if a prerequisite is listed more than once for a target, the value of `$^` contains just one copy of the name. this list does *not* contain any of the order-only prerequisites (for which ` $\| ` is required) |

```make
one: two three
	echo $@
	echo $?
	echo $^
	touch one

two:
	touch two

three:
	touch three

clean:
	rm -f one two three
```

### File Name Functions for Variables

For most functional applications of strings (for file names) see the GNU documentation [here](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions).

### Pattern and Target-Specific Variables
Variables can be assigned for specific targets:

```make
all: one = cool

all: 
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)
```
Variables can also be assigned for specific target patterns:

```make
%.c: one = cool

blah.c: 
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)
```

## Targets

If you have multiple targets and want all of them to run, use the all target:

```make
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```

When there are multiple targets for a rule, the commands will be run for each target. 
`$@`
is an automatic variable that contains the target name. Example:

```make
all: one.o two.o

one.o two.o:
	echo $@
# Equivalent to:
# one.o:
#	 echo one.o
# two.o:
#	 echo two.o
```

## Implicit Rules

| Implicit Rules | Definition | From Command |
| -- | -- | -- | 
| Compiling C | a.o is made automatically from a.c | `$(CC) -c $(CPPFLAGS) $(CFLAGS)` |
| Compiling C++ | a.o is made automatically from a.cc or a.cpp | `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)` |
| Linking a single object file | a is made automatically from a.o | `$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)`|

Important Variables:
| | |
| -- | -- |
| `CC` | program for compiling C programs; default `cc` | 
| `CXX` | program for compiling C++ programs; default `g++` |
| `CFLAGS` | extra flags to give to the C compiler |
| `CXXFLAGS` | extra flags to give to the C++ compiler |
| `CPPFLAGS` | extra flags to tive to the C preprocessor |
| `LDFLAGS` | extra flags to give to compilers when they are supposed to invoke the linker | 

```make
CC = gcc # Flag for implicit rules
CFLAGS = -g # Flag for implicit rules. Turn on debug info

# Implicit rule #1: test.c is built via the C linker implicit rule
# Implicit rule #2: test.o is built via the C compilation implicit rule, because test.c exists
# Implicit rule #3: test is built via the C linker implicit rule
test: test.o

test.c:
	echo "int main() { return 0; }" > test.c

clean:
	rm -f test*
```

## Static Pattern Rules

These rules have a distinct syntax:

```make
targets...: target-pattern: pre-req patterns ...
	recipe
```

The given
`target`
is matched by the
`target-pattern`
via
`%`
wildcard. The stem is then substituted into the
`prereq-pattern`
, to generate the target's prereqs.

A typical use case is to compile
`.c`
files into
`.o`
files. Here's the manual way:

```make
objects = foo.o bar.o all.o
all: $(objects)

# These files compile via implicit rules
foo.o: foo.c
bar.o: bar.c
all.o: all.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all
```

And here is the efficient way, using a static pattern rule:

```make
objects = foo.o bar.o all.o
all: $(objects)

# These files compile via implicit rules
# Syntax - targets ...: target-pattern: prereq-patterns ...
# In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".
# It then replaces the '%' in prereq-patterns with that stem
$(objects): %.o: %.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all
```

## Pattern Rules
Pattern rules are a way to define your own implicit rules, or perhaps a simpler form of static pattern rules. 

```make
# Define a pattern rule that compiles every .c file into a .o file
%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```

Pattern rules contain a 
`%`
in the target, which matches any nonempty string, and the other characters match themselves. 
`%` 
in a prereq of a pattern rule stands for the same stem that was matched by the
`%`
in the target.

### Double-Colon Rules
Rarely used, but allow multiple rules to be defined for the same target. With a single colon, a warning would be printed and only the last set of commands would be run:

```make
all: hello

hello::
	echo "hello"

hello::
	echo "hello again"
```

## Recipes, Commands and Execution

### Conditional
If/else statements are possible in recipes:

```make
foo = ok

all:
ifeq ($(foo), ok)
	@echo "foo equals ok"
else
	@echo "nope"
endif
```

This has a lot of utility. It can check if a variable is empty:

```make
nullstring =
foo = $("hello") # end of line; there is a space here

all:
ifeq ($(strip $(foo)),)
	echo "foo is empty after being stripped"
endif
ifeq ($(nullstring),)
	echo "nullstring doesn't even have spaces"
endif
```

It can also check if a variable is defied without expanding the variable reference:

```make
bar =
foo = $(bar)

all:
ifdef foo
	@echo "foo is defined"
endif
ifndef bar
	@echo "but bar is not"
endif
```

### Command Echoing and Silencing
Add an 
`@`
before a command to stop it from being printed. You can also run make with 
`-s`
to add an
`@`
before each line.

### Error Handling

| Flag | Result |
| -- | -- |;
| `-k` | use with `make` to continue running even with errors, good for seeing all errors |
| `-` | add before a command to surpress the error |
| `-i` | use with `make` to supress errors from all commands |

```make
one:
	# This error will be printed but ignored, and make will continue to run
	-false
	touch one
clean:
	rm one;
```

## Functions
Functions are mainly for text processing. Call functions with 
`$(fun, arguments)`
or
`${fun, arguments}
. Using the 
`call`
builtin function, it is possible to make custom functions. Find a list of builtin functions [here](https://www.gnu.org/software/make/manual/html_node/Functions.html).

### String Substitution

`(patsubst pattern,replacement,text)`
: finds whitespace separated words in a text that match pattern and replaces them with replacement. Here, pattern may contain a
`%`
which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a 
`%`
, the
`%`
is replaced by the texted that matched the
`%`
in pattern. Only the first 
`%`
in the pattern and replacement is treated this way.

The substitution reference
`(text:pattern=replacement)`
is a shorthand for this.

There's also 
`$(text:suffix=replacement)`
that replaces only suffixes.

```make
foo := a.o b.o c.o l.a
bar := d.o f.o g.o
foobar := h.o i.o j.o
one := $(patsubst %.o,%.c,$(foo))
# This is a shorthand for the above
two := $(bar:%.o=%.c)
# This is the suffix-only shorthand, and is also equivalent to the above.
three := $(foobar:.o=.c)

all:
	@echo $(one)
	@echo $(two)
	@echo $(three)
```

### foreach Function
`$(foreach var,list,text)`
converts one list of words (separated by spaces) to another.
`var`
is set to each word in list, and 
`text`
is expanded word for word. 

```make
foo := have a good day
# For each "word" in foo, output that same word with an exclamation after
bar := $(foreach wrd,$(foo),$(wrd)!)
# Output is "have! a! good! day!"
all:
	@echo $(bar)
```

### if Function
`if`
checks if the first argument is empty. If it isn't empty, the second argument is run. If it is empty, the third argument is run.

```made
not-empty := "hello"
foo := $(if $(not-empty),then!,else!)
empty :=
bar := $(if $(empty),then!,else!)

all:
	@echo $(foo)
	@echo $(bar)
```

### call Function
Make supports creating basic functions. You "define" the funtion by crating a veriable, but use the parameters
`$(0)`
,
`$(1)`
etc. You then call the function with the
`call`
function. The syntax is
`$(call variable,param,param)`
.
`$(0)`
is the variable, while
`$(1)`
,
`$(2)`
, etc. are the parameters.

```make
new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)

all:
	@echo $(call new_fn, hello,world)
	@echo $(call new_fn, hello,world,empty)
```

## General Concepts

* Flags can be arranged in any order, ie:
 `ls -la`
is equivalent to 
`ls -al`

* If you want to understand why a specific flag is being used with a command, consult the
manual: 
`man ls`

* The backslash character
`\`
gives us the ability to use multiple lines when commands are too long:

```make
some_file: 
	@echo This line is too long, so \
		it is broken up into multiple lines
```
* Adding 
`.PHONY` 
to a target will prevent make from confusing the phony target with a file name. For example, if you have a file called clean, you can stil run a traditional clean function. It is best practice to use phony on all targets that are not file names.

```make
some_file:
	touch some_file
	touch clean

.PHONY: clean
clean:
	rm -f some_file
	rm -f clean
```

# Sources
* https://makefiletutorial.com/
* https://www.gnu.org/software/make/manual/make.html
# Notes
Alternatives to traditional makefiles:
* https://cmake.org/
* https://bazel.build/
* https://ninja-build.org/
* https://scons.org/